{
  "version": 3,
  "sources": ["../../@tiptap/suggestion/src/findSuggestionMatch.ts", "../../@tiptap/suggestion/src/suggestion.ts"],
  "sourcesContent": ["import { escapeForRegEx, Range } from '@tiptap/core'\nimport { ResolvedPos } from 'prosemirror-model'\n\nexport interface Trigger {\n  char: string,\n  allowSpaces: boolean,\n  allowedPrefixes: string[] | null,\n  startOfLine: boolean,\n  $position: ResolvedPos,\n}\n\nexport type SuggestionMatch = {\n  range: Range,\n  query: string,\n  text: string,\n} | null\n\nexport function findSuggestionMatch(config: Trigger): SuggestionMatch {\n  const {\n    char,\n    allowSpaces,\n    allowedPrefixes,\n    startOfLine,\n    $position,\n  } = config\n\n  const escapedChar = escapeForRegEx(char)\n  const suffix = new RegExp(`\\\\s${escapedChar}$`)\n  const prefix = startOfLine ? '^' : ''\n  const regexp = allowSpaces\n    ? new RegExp(`${prefix}${escapedChar}.*?(?=\\\\s${escapedChar}|$)`, 'gm')\n    : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\\\s${escapedChar}]*`, 'gm')\n\n  const text = $position.nodeBefore?.isText && $position.nodeBefore.text\n\n  if (!text) {\n    return null\n  }\n\n  const textFrom = $position.pos - text.length\n  const match = Array.from(text.matchAll(regexp)).pop()\n\n  if (!match || match.input === undefined || match.index === undefined) {\n    return null\n  }\n\n  // JavaScript doesn't have lookbehinds. This hacks a check that first character\n  // is a space or the start of the line\n  const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index)\n  const matchPrefixIsAllowed = new RegExp(`^[${allowedPrefixes?.join('')}\\0]?$`).test(matchPrefix)\n\n  if (allowedPrefixes !== null && !matchPrefixIsAllowed) {\n    return null\n  }\n\n  // The absolute position of the match in the document\n  const from = textFrom + match.index\n  let to = from + match[0].length\n\n  // Edge case handling; if spaces are allowed and we're directly in between\n  // two triggers\n  if (allowSpaces && suffix.test(text.slice(to - 1, to + 1))) {\n    match[0] += ' '\n    to += 1\n  }\n\n  // If the $position is located within the matched substring, return that range\n  if (from < $position.pos && to >= $position.pos) {\n    return {\n      range: {\n        from,\n        to,\n      },\n      query: match[0].slice(char.length),\n      text: match[0],\n    }\n  }\n\n  return null\n}\n", "import { Editor, Range } from '@tiptap/core'\nimport { EditorState, Plugin, PluginKey } from 'prosemirror-state'\nimport { Decoration, DecorationSet, EditorView } from 'prosemirror-view'\n\nimport { findSuggestionMatch } from './findSuggestionMatch'\n\nexport interface SuggestionOptions<I = any> {\n  pluginKey?: PluginKey,\n  editor: Editor,\n  char?: string,\n  allowSpaces?: boolean,\n  allowedPrefixes?: string[] | null,\n  startOfLine?: boolean,\n  decorationTag?: string,\n  decorationClass?: string,\n  command?: (props: {\n    editor: Editor,\n    range: Range,\n    props: I,\n  }) => void,\n  items?: (props: {\n    query: string,\n    editor: Editor,\n  }) => I[] | Promise<I[]>,\n  render?: () => {\n    onBeforeStart?: (props: SuggestionProps<I>) => void\n    onStart?: (props: SuggestionProps<I>) => void,\n    onBeforeUpdate?: (props: SuggestionProps<I>) => void\n    onUpdate?: (props: SuggestionProps<I>) => void,\n    onExit?: (props: SuggestionProps<I>) => void,\n    onKeyDown?: (props: SuggestionKeyDownProps) => boolean,\n  },\n  allow?: (props: {\n    editor: Editor,\n    state: EditorState,\n    range: Range,\n  }) => boolean,\n}\n\nexport interface SuggestionProps<I = any> {\n  editor: Editor,\n  range: Range,\n  query: string,\n  text: string,\n  items: I[],\n  command: (props: I) => void,\n  decorationNode: Element | null,\n  clientRect?: (() => DOMRect | null) | null,\n}\n\nexport interface SuggestionKeyDownProps {\n  view: EditorView,\n  event: KeyboardEvent,\n  range: Range,\n}\n\nexport const SuggestionPluginKey = new PluginKey('suggestion')\n\nexport function Suggestion<I = any>({\n  pluginKey = SuggestionPluginKey,\n  editor,\n  char = '@',\n  allowSpaces = false,\n  allowedPrefixes = [' '],\n  startOfLine = false,\n  decorationTag = 'span',\n  decorationClass = 'suggestion',\n  command = () => null,\n  items = () => [],\n  render = () => ({}),\n  allow = () => true,\n}: SuggestionOptions<I>) {\n\n  let props: SuggestionProps<I> | undefined\n  const renderer = render?.()\n\n  const plugin: Plugin<any> = new Plugin({\n    key: pluginKey,\n\n    view() {\n      return {\n        update: async (view, prevState) => {\n          const prev = this.key?.getState(prevState)\n          const next = this.key?.getState(view.state)\n\n          // See how the state changed\n          const moved = prev.active && next.active && prev.range.from !== next.range.from\n          const started = !prev.active && next.active\n          const stopped = prev.active && !next.active\n          const changed = !started && !stopped && prev.query !== next.query\n          const handleStart = started || moved\n          const handleChange = changed && !moved\n          const handleExit = stopped || moved\n\n          // Cancel when suggestion isn't active\n          if (!handleStart && !handleChange && !handleExit) {\n            return\n          }\n\n          const state = handleExit && !handleStart\n            ? prev\n            : next\n          const decorationNode = view.dom.querySelector(`[data-decoration-id=\"${state.decorationId}\"]`)\n\n          props = {\n            editor,\n            range: state.range,\n            query: state.query,\n            text: state.text,\n            items: [],\n            command: commandProps => {\n              command({\n                editor,\n                range: state.range,\n                props: commandProps,\n              })\n            },\n            decorationNode,\n            // virtual node for popper.js or tippy.js\n            // this can be used for building popups without a DOM node\n            clientRect: decorationNode\n              ? () => {\n                // because of `items` can be asynchrounous we\u2019ll search for the current decoration node\n                const { decorationId } = this.key?.getState(editor.state) // eslint-disable-line\n                const currentDecorationNode = view.dom.querySelector(`[data-decoration-id=\"${decorationId}\"]`)\n\n                return currentDecorationNode?.getBoundingClientRect() || null\n              }\n              : null,\n          }\n\n          if (handleStart) {\n            renderer?.onBeforeStart?.(props)\n          }\n\n          if (handleChange) {\n            renderer?.onBeforeUpdate?.(props)\n          }\n\n          if (handleChange || handleStart) {\n            props.items = await items({\n              editor,\n              query: state.query,\n            })\n          }\n\n          if (handleExit) {\n            renderer?.onExit?.(props)\n          }\n\n          if (handleChange) {\n            renderer?.onUpdate?.(props)\n          }\n\n          if (handleStart) {\n            renderer?.onStart?.(props)\n          }\n        },\n\n        destroy: () => {\n          if (!props) {\n            return\n          }\n\n          renderer?.onExit?.(props)\n        },\n      }\n    },\n\n    state: {\n      // Initialize the plugin's internal state.\n      init() {\n        const state: {\n          active: boolean,\n          range: Range,\n          query: null | string\n          text: null | string\n          composing: boolean\n          decorationId?: string | null\n        } = {\n          active: false,\n          range: {\n            from: 0,\n            to: 0,\n          },\n          query: null,\n          text: null,\n          composing: false,\n        }\n\n        return state\n      },\n\n      // Apply changes to the plugin state from a view transaction.\n      apply(transaction, prev, oldState, state) {\n        const { isEditable } = editor\n        const { composing } = editor.view\n        const { selection } = transaction\n        const { empty, from } = selection\n        const next = { ...prev }\n\n        next.composing = composing\n\n        // We can only be suggesting if the view is editable, and:\n        //   * there is no selection, or\n        //   * a composition is active (see: https://github.com/ueberdosis/tiptap/issues/1449)\n        if (isEditable && (empty || editor.view.composing)) {\n          // Reset active state if we just left the previous suggestion range\n          if (\n            ((from < prev.range.from) || from > prev.range.to)\n            && !composing\n            && !prev.composing\n          ) {\n            next.active = false\n          }\n\n          // Try to match against where our cursor currently is\n          const match = findSuggestionMatch({\n            char,\n            allowSpaces,\n            allowedPrefixes,\n            startOfLine,\n            $position: selection.$from,\n          })\n          const decorationId = `id_${Math.floor(Math.random() * 0xFFFFFFFF)}`\n\n          // If we found a match, update the current state to show it\n          if (match && allow({ editor, state, range: match.range })) {\n            next.active = true\n            next.decorationId = prev.decorationId ? prev.decorationId : decorationId\n            next.range = match.range\n            next.query = match.query\n            next.text = match.text\n          } else {\n            next.active = false\n          }\n        } else {\n          next.active = false\n        }\n\n        // Make sure to empty the range if suggestion is inactive\n        if (!next.active) {\n          next.decorationId = null\n          next.range = { from: 0, to: 0 }\n          next.query = null\n          next.text = null\n        }\n\n        return next\n      },\n    },\n\n    props: {\n      // Call the keydown hook if suggestion is active.\n      handleKeyDown(view, event) {\n        const { active, range } = plugin.getState(view.state)\n\n        if (!active) {\n          return false\n        }\n\n        return renderer?.onKeyDown?.({ view, event, range }) || false\n      },\n\n      // Setup decorator on the currently active suggestion.\n      decorations(state) {\n        const { active, range, decorationId } = plugin.getState(state)\n\n        if (!active) {\n          return null\n        }\n\n        return DecorationSet.create(state.doc, [\n          Decoration.inline(range.from, range.to, {\n            nodeName: decorationTag,\n            class: decorationClass,\n            'data-decoration-id': decorationId,\n          }),\n        ])\n      },\n    },\n  })\n\n  return plugin\n}\n"],
  "mappings": "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",
  "names": ["_a"]
}
